from collections import Counter
from random import shuffle
 
 
def 计算提示(猜测配方, 正确配方):
    '''对于给定的猜测和正确配方，计算出应该获得的提示'''
    猜测_内部 = 猜测配方[:]#别问为啥有这两行
    正确_内部 = 正确配方[:]
    返回值 = [0, 0]#[荧石粉数量, 红石粉数量]
    for i in range(4):#计算荧石粉的数量
        if 猜测_内部[i] == 正确_内部[i]:
            返回值[0] += 1
            猜测_内部[i] = ''#移除配对成功的值，但不影响索引
            正确_内部[i] = 0#移除值时，将两个列表中的值修改为不同的值，以防移除的值被下一步配对
    for i in 正确_内部:#计算红石粉的数量
        if i in 猜测_内部:
            返回值[1] += 1
            猜测_内部.remove(i)#此处仅移除其中一个列表的值，以免影响循环
    return 返回值
 
#别问为啥有下面这三个函数
def updated(被更新字典, 更新源字典):
    '''更新字典且返回更新后的字典'''
    字典_内部 = 被更新字典
    字典_内部.update(更新源字典)
    return 字典_内部
 
def shuffled(目标列表):
    '''随机排列列表中的元素且返回随机排列后的列表'''
    列表_内部 = 目标列表
    shuffle(列表_内部)
    return 列表_内部
 
def 第一个元素(序列): return 序列[0]
 
 
剩余配方 = []
输入的猜测 = []
输入的提示 = []
可行的猜测 = []
在剩余配方中的可行的猜测 = []
不在剩余配方中的可行的猜测 = []
 
print('''此程序在Python3.7.7中编写，用于在CAB整合包的Chaotic Alchemy玩法中寻找Catalyst的合成配方
请输入6位数字，其中前4位是你尝试的配方，后两位是你获得的提示（荧石和红石的数量）
输入quit退出程序，输入reset重置程序''')
 
 
while True:
    用户输入 = input('>')#输入一个六位数字，前四位是尝试的配方，后两位是获得的提示
     
    if 用户输入 == 'quit':
        break
    elif 用户输入 == 'reset':
        剩余配方.clear()
        print('已重置')
         
    else:
        输入的猜测[:] = [int(i) for i in 用户输入[:4]]#拆分输入的配方和提示，并将其转换为列表
        输入的提示[:] = [int(i) for i in 用户输入[4:]]
         
        if len(剩余配方):#判断当前循环是否不是第一次猜测配方
            #如果不是第一次，对于当前剩余配方列表的每个配方，如果其对输入的猜测配方应有的提示和实际输入的提示不同，移除该配方，否则保留它
            剩余配方[:] = [i for i in 剩余配方 if 计算提示(输入的猜测, i) == 输入的提示]
        else:#如果是第一次，嵌套四个循环来生成所有可能的配方，并移除其中计算出的提示和输入的提示不同的配方
            剩余配方[:] = [[i1 + 1, i2 + 1, i3 + 1, i4 + 1] for i1 in range(6) for i2 in range(6) for i3 in range(6) for i4 in range(6) if 计算提示(输入的猜测, [i1 + 1, i2 + 1, i3 + 1, i4 + 1]) == 输入的提示]
             
        if len(剩余配方):#判断是否有剩余配方，用于在发生错误时发出提示
            if len(剩余配方) - 1:#判断剩余配方是否多于一个
                print('剩余{}个可能的配方'.format(len(剩余配方)))#如果是，输出剩余配方数量
                if len(剩余配方) < 10:#如果剩余配方少于十个，输出它们
                    print('它们分别是：', ' '.join([''.join([str(i1) for i1 in i2]) for i2 in 剩余配方]))
            else:#如果不是，配方已确定，输出该配方并自动重置程序
                print('配方已确定为{}'.format(''.join([str(i) for i in 剩余配方[0]])))
                剩余配方.clear()
                print('已自动重置')
                continue
        else:
            print('没有剩余的配方，你可能输入了错误的数据，或此程序存在漏洞')
            剩余配方.clear()
            print('已自动重置')
            continue
 
        #对于每个可行的猜测，统计剩余配方列表中的配方给出的除[4, 0]外每个可能的提示的数量
        在剩余配方中的可行的猜测[:] = [list(updated({(i3, i4): 0 for i3 in range(5) for i4 in range(5) if i3 + i4 < 5 and (i3, i4) not in [(4, 0), (3, 1)]}, Counter([tuple(计算提示(i1, i2)) for i2 in 剩余配方 if 计算提示(i1, i2) != [4, 0]])).values()) + [i1] for i1 in 剩余配方]
        #我们希望其他条件相同时在剩余配方列表中的猜测更优先，但又想让多个所有条件都相同的猜测随机排列，因此分别生成在和不在剩余配方列表中的猜测列表，分别随机排列并排序后归并，归并时在剩余配方列表中的猜测优先
        不在剩余配方中的可行的猜测[:] = [list(updated({(i6, i7): 0 for i6 in range(5) for i7 in range(5) if i6 + i7 < 5 and (i6, i7) not in [(4, 0), (3, 1)]}, Counter([tuple(计算提示([i1 + 1, i2 + 1, i3 + 1, i4 + 1], i5)) for i5 in 剩余配方 if 计算提示([i1 + 1, i2 + 1, i3 + 1, i4 + 1], i5) != [4, 0]])).values()) + [[i1 + 1, i2 + 1, i3 + 1, i4 + 1]] for i1 in range(6) for i2 in range(6) for i3 in range(6) for i4 in range(6) if [i1 + 1, i2 + 1, i3 + 1, i4 + 1] not in 剩余配方]
        #对于每个可行的猜测，用此猜测获得的最多的提示与其获得的最少的提示作差，并按所得的差从小到大对猜测排序，别问为啥往排序里加个key，问就是这排序函数发现第一个依据相同时默认会找第二个依据来排序，但这不是我们想要的
        在剩余配方中的可行的猜测[:] = sorted(shuffled([[max(i[:-1]) - min(i[:-1]), i[-1]] for i in 在剩余配方中的可行的猜测]), key = 第一个元素)
        不在剩余配方中的可行的猜测[:] = sorted(shuffled([[max(i[:-1]) - min(i[:-1]), i[-1]] for i in 不在剩余配方中的可行的猜测]), key = 第一个元素)
 
        可行的猜测.clear()
        while len(在剩余配方中的可行的猜测) and len(不在剩余配方中的可行的猜测):
            if 在剩余配方中的可行的猜测[0][0] > 不在剩余配方中的可行的猜测[0][0]:#相等的情况包含在else中，因此在剩余配方列表中的猜测会更优先
                可行的猜测.append(不在剩余配方中的可行的猜测.pop(0))
            else:
                可行的猜测.append(在剩余配方中的可行的猜测.pop(0))
        可行的猜测.extend(在剩余配方中的可行的猜测)
        可行的猜测.extend(不在剩余配方中的可行的猜测)
         
        print('建议猜测：', ' '.join([''.join([str(i1) for i1 in i2[1]]) for i2 in 可行的猜测[:10]]))#输出最靠前的多个猜测作为建议
